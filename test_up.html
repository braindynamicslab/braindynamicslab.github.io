<!DOCTYPE html>
<html>
  <head>
    <title>Processing.js Example Page</title>
    <meta charset="UTF-8">
    <script type="text/javascript" src="processing1.4.8.js"></script>

    <!--
        This is a source-file-less sketch, loaded from inline source code in
        the html header. This only works if the script specifies a data-processing-target
    -->
  </head>

  <body>
    <canvas data-processing-sources="LeapsCentroid.pde ExitButton.pde Tile.pde GallerySpace.pde TextField.pde RadioButton.pde" style="border: 1px solid black;"></canvas>
	<script type="application/javascript">  
	var xmlhttp;
    (function anonymous(
) {
return (// this code was autogenerated from PJS
(function($p) {
var ExitButton = (function() {
function ExitButton() {
var $this_1 = this;
function $superCstr(){$p.extendClassChain($this_1)}
$this_1.myWidth = 0;
$this_1.myHeight = 0;
$this_1.myPos = null;
$this_1.t = null;
function display$0() {
$p.strokeWeight(2);
    $p.noStroke();
    if ($this_1.$self.over()) {
$p.stroke(hue2,satHI,valHI);
}

    $p.fill(hue2,100,40);
    $p.rectMode($p.CORNER);
    $p.rect($this_1.myPos.x,$this_1.myPos.y,$this_1.myWidth,$this_1.myHeight);

    if ($this_1.$self.over()) {
if(!ratingShapes) {
$p.stroke(0,0,0);
        $p.line($this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y,$this_1.myPos.x+$this_1.myWidth,$this_1.myPos.y+$this_1.myHeight/2);
        $p.line($this_1.myPos.x+$this_1.myWidth,$this_1.myPos.y+$this_1.myHeight/2,$this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y+$this_1.myHeight);
        $p.line($this_1.myPos.x,$this_1.myPos.y+$this_1.myHeight/2,$this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y+$this_1.myHeight/2);
        $p.line($this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y,$this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y+$this_1.myHeight);
}
      else if (ratingShapes) {
$p.stroke(0,0,0);
        $p.line($this_1.myPos.x,$this_1.myPos.y,$this_1.myPos.x+$this_1.myWidth,$this_1.myPos.y+$this_1.myHeight);
        $p.line($this_1.myPos.x+$this_1.myWidth,$this_1.myPos.y,$this_1.myPos.x,$this_1.myPos.y+$this_1.myHeight);
}
      $p.fill(hue1,100,100);
      if(notGotDemosYet) {
$p.textAlign($p.LEFT, $p.BOTTOM);
        $p.text($this_1.t,$this_1.myPos.x+$this_1.myWidth,$this_1.myPos.y+$p.textAscent()+$p.textDescent());
} else {
$p.textAlign($p.RIGHT, $p.BOTTOM);
        $p.text($this_1.t,$this_1.myPos.x,$this_1.myPos.y+$p.textAscent()+$p.textDescent());
}
}
}
$p.addMethod($this_1, 'display', display$0, false);
function over$0() {
if ($p.mouseX>$this_1.myPos.x && $p.mouseX<($this_1.myPos.x+$this_1.myWidth) && $p.mouseY>$this_1.myPos.y && $p.mouseY<($this_1.myPos.y+$this_1.myHeight)) {
return true;
} else {
return false;
}
}
$p.addMethod($this_1, 'over', over$0, false);
function $constr_0(){
$superCstr();

$this_1.myWidth = 15;
    $this_1.myHeight = 15;
    $this_1.myPos = new $p.PVector(5,5);
    $this_1.t = "";
}

function $constr() {
if(arguments.length === 0) { $constr_0.apply($this_1, arguments); } else $superCstr();
}
$constr.apply(null, arguments);
}
return ExitButton;
})();
$p.ExitButton = ExitButton;
var Tile = (function() {
function Tile() {
var $this_1 = this;
function $superCstr(){$p.extendClassChain($this_1)}
$this_1.mySize = 0;
$this_1.ID = 0;
$this_1.myMinoPos = null;
$this_1.myColor = 0x00000000;
$this_1.positionSpread = false;
$this_1.carried = false;
$this_1.isSeperable = false;
$this_1.visited = false;
$this_1.notSpreadYet = false;
$this_1.animationCounter = 0;
$this_1.activationCounter = 0;
$this_1.above = null;
$this_1.below = null;
$this_1.left = null;
$this_1.right = null;
function display$0() {
$p.fill($this_1.myColor);
    if(($this_1.isSeperable && $this_1.$self.over() && !carrying) || $this_1.carried) {
$this_1.$self.animateSeparability();
}
    $p.strokeWeight(2);

    if(($this_1.isSeperable && $this_1.$self.over() && !carrying) || $this_1.carried){
$p.stroke(hue1,satHI,valLO);
} 
    else {
$p.noStroke();
}

    $p.rectMode($p.CENTER);
    $p.rect($this_1.myMinoPos.x,$this_1.myMinoPos.y,$this_1.mySize-5,$this_1.mySize-5);

    if ($this_1.activationCounter > 0 ) {
$this_1.$self.spreadActivation();
      $p.fill(hue1+10,satHI,valHI,75);
             $p.rect($this_1.myMinoPos.x,$this_1.myMinoPos.y,$this_1.mySize-5,$this_1.mySize-5);
}
}
$p.addMethod($this_1, 'display', display$0, false);
function over$0() {
var x0 =  $this_1.myMinoPos.x - $this_1.mySize/2 + ($p.width )/2 - minoCentroid.x;
    var x1 =  $this_1.myMinoPos.x + $this_1.mySize/2 + ($p.width )/2 - minoCentroid.x;
    var y0 =  $this_1.myMinoPos.y - $this_1.mySize/2 + $p.height/2 - minoCentroid.y;
    var y1 =  $this_1.myMinoPos.y + $this_1.mySize/2 + $p.height/2 - minoCentroid.y;

    return $p.mouseX > x0 && $p.mouseX < x1 && $p.mouseY > y0 && $p.mouseY < y1;
}
$p.addMethod($this_1, 'over', over$0, false);
function animateSeparability$0() {
$this_1.animationCounter = ($this_1.animationCounter + 1) % 60;
    if ($this_1.animationCounter < 30) {
$p.fill(hue1,satHI,valHI-$this_1.animationCounter);
} 
    else {
$p.fill(hue1,satHI,valHI-60+$this_1.animationCounter);
}
}
$p.addMethod($this_1, 'animateSeparability', animateSeparability$0, false);
function spreadActivation$0() {
$this_1.notSpreadYet = false;
    $this_1.activationCounter += 1;
    if ($this_1.activationCounter > 4) {
if($this_1.left != null && $this_1.left.notSpreadYet) {
$this_1.left.spreadActivation();
}
      if($this_1.right != null && $this_1.right.notSpreadYet) {
$this_1.right.spreadActivation();
}
      if($this_1.above != null && $this_1.above.notSpreadYet) {
$this_1.above.spreadActivation();
}
      if($this_1.below != null && $this_1.below.notSpreadYet) {
$this_1.below.spreadActivation();
}
      $this_1.activationCounter = 0;
}
}
$p.addMethod($this_1, 'spreadActivation', spreadActivation$0, false);
function $constr_0(){
$superCstr();

$this_1.mySize = $p.min($p.width ,$p.height)/(minoSize+1);
    $this_1.myMinoPos = new $p.PVector(0,0); 
    $this_1.myColor = $p.color(hue1,satHI,valHI);
    $this_1.positionSpread = false;
    $this_1.carried = false;
    $this_1.isSeperable = true;
    $this_1.visited = false;
    $this_1.notSpreadYet = true;

    $this_1.animationCounter = 0;
    $this_1.activationCounter = 0;

    $this_1.above = null;
    $this_1.below = null;
    $this_1.left = null;
    $this_1.right = null;
    $this_1.ID = $p.random(1000);
}

function $constr() {
if(arguments.length === 0) { $constr_0.apply($this_1, arguments); } else $superCstr();
}
$constr.apply(null, arguments);
}
return Tile;
})();
$p.Tile = Tile;
var GallerySpace = (function() {
function GallerySpace() {
var $this_1 = this;
function $superCstr(){$p.extendClassChain($this_1)}
$this_1.myPos = null;
$this_1.myCentroid = null;
$this_1.myMinoLayout = null;
$this_1.mySize = 0;
$this_1.tileSize = 0;
$this_1.t = null;
$this_1.selected = false;
function display$0() {
$p.rectMode($p.CORNER);
    $p.fill(0,0,50);
    if ($this_1.selected) {
$p.fill(hue2,100,50);
      $p.stroke(hue2,100,100);
      $p.strokeWeight(2);
      $p.rect($this_1.myPos.x,$this_1.myPos.y,$this_1.mySize-2,$this_1.mySize-2);
} else {
$p.stroke(0,0,15);
}
    if ($this_1.$self.over() && !carrying) {
$p.strokeWeight(2);
      $p.stroke(15,100,80);
}
    $p.strokeWeight(2);
    $p.rect($this_1.myPos.x,$this_1.myPos.y,$this_1.mySize-2,$this_1.mySize-2);

    $p.strokeWeight(1);
    $p.stroke(0,0,15);
    if ($this_1.myMinoLayout != null) $this_1.$self.drawMyMino();
}
$p.addMethod($this_1, 'display', display$0, false);
function drawMyMino$0() {
$p.fill(hue1,satHI,80);

    $p.rectMode($p.CENTER);

    $p.pushMatrix();
    $p.translate($this_1.myPos.x+$this_1.mySize/2-$this_1.myCentroid.x,$this_1.myPos.y+$this_1.mySize/2-$this_1.myCentroid.y);

    for (var j = 0;  j<minoSize;  j++) {
var row =  $p.binary($this_1.myMinoLayout[j]); 
      for (var i = 0;  i<row.length;  i++) {
if (row.charAt(i) == "1") {
$p.rect($this_1.tileSize*(i+minoSize-row.length),$this_1.tileSize*j,$this_1.tileSize,$this_1.tileSize);
}
}
}

    $p.popMatrix();
}
$p.addMethod($this_1, 'drawMyMino', drawMyMino$0, false);
function findMyCentroid$0() {
var x =  0;
    var y =  0;

    for (var j = 0;  j<minoSize;  j++) {
var row =  $p.binary($this_1.myMinoLayout[j]); 
      for (var i = 0;  i<row.length;  i++) {
if (row.charAt(i) == "1") {
x += i+minoSize-row.length;
          y += j;
}
}
}

    $this_1.myCentroid.x = $this_1.tileSize * x/$p.parseFloat(minoSize);
    $this_1.myCentroid.y = $this_1.tileSize * y/$p.parseFloat(minoSize);
}
$p.addMethod($this_1, 'findMyCentroid', findMyCentroid$0, false);
function over$0() {
if($p.mouseX>$this_1.myPos.x && $p.mouseX<($this_1.myPos.x+$this_1.mySize) && $p.mouseY>$this_1.myPos.y && $p.mouseY<($this_1.myPos.y+$this_1.mySize)) {
return true;
} else {
return false;
}
}
$p.addMethod($this_1, 'over', over$0, false);
function $constr_4(x, y, gssize, s){
$superCstr();

$this_1.myPos = new $p.PVector(0,0);
    $this_1.myCentroid = new $p.PVector(0,0);
    $this_1.myMinoLayout = null;   
    $this_1.t = "";
    $this_1.selected = false;
    $this_1.myPos.x = x;
    $this_1.myPos.y = y;
    $this_1.mySize = gssize;
    $this_1.tileSize = $this_1.mySize/(minoSize+1);
    $this_1.t = s;
}

function $constr() {
if(arguments.length === 4) { $constr_4.apply($this_1, arguments); } else $superCstr();
}
$constr.apply(null, arguments);
}
return GallerySpace;
})();
$p.GallerySpace = GallerySpace;
var TextField = (function() {
function TextField() {
var $this_1 = this;
function $superCstr(){$p.extendClassChain($this_1)}
$this_1.pos = null;
$this_1.dim = null;
$this_1.label = null;
$this_1.field = null;
$this_1.font = null;
$this_1.focus = false;
function display$0() {
$p.fill(50,0,50);
    $p.rectMode($p.CORNER);
    $p.strokeWeight(1);
    $p.stroke(50,0,150);
    if($this_1.focus) $p.stroke(25,100,100);
    if($this_1.$self.over()) $p.stroke(15,100,100);
    $p.rect($this_1.pos.x,$this_1.pos.y,$this_1.dim.x,$this_1.dim.y);

    $p.textAlign($p.LEFT, $p.BOTTOM);
    $p.fill(hue1,100,100);
    $p.text($this_1.label,$this_1.pos.x,$this_1.pos.y-$p.textDescent());
    $p.textAlign($p.RIGHT, $p.BOTTOM);
    $p.fill(0,0,100);
    $p.text($this_1.field,$this_1.pos.x+$this_1.dim.x,$this_1.pos.y+$this_1.dim.y);
}
$p.addMethod($this_1, 'display', display$0, false);
function processKeyPress$0() {
if ($p.key == $p.BACKSPACE || $p.key == $p.DELETE) {
if($this_1.field.length> 0){
$this_1.field = $this_1.field.substring(0,$this_1.field.length-1);
}
}

    else if($p.key != $p.RETURN && $p.key != $p.ENTER) {
if ($p.textWidth(""+$this_1.field+$p.key)<$this_1.dim.x) {
$this_1.field += String.fromCharCode($p.key);
}
}
}
$p.addMethod($this_1, 'processKeyPress', processKeyPress$0, false);
function over$0() {
if($p.mouseX>$this_1.pos.x && $p.mouseX<$this_1.pos.x+$this_1.dim.x && $p.mouseY>$this_1.pos.y && $p.mouseY<$this_1.pos.y+$this_1.dim.y) {
return true;
} 
    else {
return false;
}
}
$p.addMethod($this_1, 'over', over$0, false);
function $constr_3(x, y, l){
$superCstr();

$this_1.pos = new $p.PVector(0,0);
    $this_1.dim = new $p.PVector(100,20);
    $this_1.field = "";
    $this_1.focus = false;

    $this_1.font = $p.loadFont("ArialUnicodeMS-22.vlw");
    $p.textFont($this_1.font,22);
    $this_1.dim.y = $p.textAscent() + $p.textDescent() + 6;
    $this_1.dim.x = $p.textWidth("female")+5;

    $this_1.pos.x = x;
    $this_1.pos.y = y;
    $this_1.label = l;
}

function $constr() {
if(arguments.length === 3) { $constr_3.apply($this_1, arguments); } else $superCstr();
}
$constr.apply(null, arguments);
}
return TextField;
})();
$p.TextField = TextField;
var RadioButton = (function() {
function RadioButton() {
var $this_1 = this;
function $superCstr(){$p.extendClassChain($this_1)}
$this_1.myWidth = 0;
$this_1.myHeight = 0;
$this_1.myPos = null;
$this_1.f = false;
$this_1.m = false;
$this_1.label = null;
function display$0() {
$p.strokeWeight(2);
    $p.noStroke();
    if ($this_1.$self.over()) {

}

    $p.textAlign($p.LEFT, $p.BOTTOM);
    $p.fill(hue1,100,100);
    $p.text($this_1.label,$this_1.myPos.x,$this_1.myPos.y-$p.textDescent());

    $p.fill(hue2,0,255);
    $p.ellipseMode($p.CENTER);
    $p.ellipse($this_1.myPos.x+$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,$this_1.myHeight/2,$this_1.myHeight/2);
    $p.ellipse($this_1.myPos.x+3*$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,$this_1.myHeight/2,$this_1.myHeight/2);
    $p.stroke(hue2,0,55);
    $p.fill(hue1,0,0);
    $p.ellipse($this_1.myPos.x+$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,0.7*($this_1.myHeight/2),0.7*($this_1.myHeight/2));
    $p.ellipse($this_1.myPos.x+3*$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,0.7*$this_1.myHeight/2,0.7*$this_1.myHeight/2);
    $p.noStroke();
    if ($this_1.m) {
$p.fill(hue2,0,255);
      $p.noStroke();
      $p.ellipse($this_1.myPos.x+$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,0.7*($this_1.myHeight/2),0.7*($this_1.myHeight/2));
      $p.fill(hue1,0,0);
}
    if ($this_1.f) {
$p.fill(hue2,0,255);
      $p.noStroke();
      $p.ellipse($this_1.myPos.x+3*$this_1.myHeight/2,$this_1.myPos.y+$this_1.myHeight/2,0.7*$this_1.myHeight/2,0.7*$this_1.myHeight/2);
      $p.fill(hue1,0,0);
}

    $p.fill(hue2,0,255);
    if ($this_1.$self.over()) $p.fill(15,255,255);
    $p.textFont(smallFont,22);
    $p.text("m",$this_1.myPos.x-10,$this_1.myPos.y+$this_1.myHeight/1.3);
    $p.text("f",$this_1.myPos.x+$this_1.myWidth/2,$this_1.myPos.y+$this_1.myHeight/1.3);
}
$p.addMethod($this_1, 'display', display$0, false);
function over$0() {
if ($p.mouseX>$this_1.myPos.x && $p.mouseX<($this_1.myPos.x+$this_1.myWidth) && $p.mouseY>$this_1.myPos.y && $p.mouseY<($this_1.myPos.y+$this_1.myHeight)) {
return true;
} else {
return false;
}
}
$p.addMethod($this_1, 'over', over$0, false);
function setFlag$0() {
if ($this_1.$self.over() && $p.mouseX<=($this_1.myPos.x+$this_1.myWidth/2)) {
$this_1.m = true;
      $this_1.f = false;
}
    if ($this_1.$self.over() && $p.mouseX>($this_1.myPos.x+$this_1.myWidth/2)) {
$this_1.m = false;
      $this_1.f = true;
}
}
$p.addMethod($this_1, 'setFlag', setFlag$0, false);
function $constr_1(l){
$superCstr();

$this_1.myWidth = 100  ;
    $this_1.myHeight = 50;
    $this_1.myPos = new $p.PVector(5,5);
    $this_1.f = false;
    $this_1.m = false;
    $this_1.label = l;
}

function $constr() {
if(arguments.length === 1) { $constr_1.apply($this_1, arguments); } else $superCstr();
}
$constr.apply(null, arguments);
}
return RadioButton;
})();
$p.RadioButton = RadioButton;

var hue1 = 0; var hue2 = 0; var satHI = 0; var satLO = 0; var valHI = 0; var valMID = 0; var valLO = 0; 
var minoSize = 0; var tiles = null;

var appHeight = 0; var gallerySize = 0; var rightPanel = 0; var appWidth = 0; 
var currentMinoLayout = null;
var sessionID = 0; var ratingCount = 0; var sessionString = null; var maxSessionTime = 0; var e = null; var d = null; var s = null; var font = null;
var smallFont = null;
var notStartedYet = false; var notGotDemosYet = false; var ratingShapes = false; var needRatingShapesMessage = false; var gallerySelection =  false;
var tf1 = null;
 var r1 = null;

var uMinos = null; var selectedMinos = null; var trajectory = null;  
var minoCentroid = null; 
var carrying = false; 
var carried = null; 
var visitedCount = 0;

var bg = 0x00000000;

var gallery = null; var ratingGallery = null;

function setup() {
hue1 = 25;
  hue2 = 0;
  satHI = 95;
  satLO = 30;
  valHI = 90;
  valMID = 50;
  valLO = 30;
  minoSize = 10;
  tiles = $p.createJavaArray('Tile', [minoSize]);
  appHeight = 600;
  gallerySize = 1;
  rightPanel = appHeight/5;   appWidth = appHeight;   sessionID =  $p.__int_cast($p.random(0,1000000));
  ratingCount = 0;
  sessionString = sessionID+"-"+$p.year()+$p.nf($p.month(),2)+$p.nf($p.day(),2)+"-"+$p.nf($p.hour(),2)+$p.nf($p.minute(),2)+$p.nf($p.second(),2);
  maxSessionTime = 25*60*1000;
  e = new ExitButton();
  d = new ExitButton();
  s = new ExitButton();
  notStartedYet = false;
  notGotDemosYet = true;
  ratingShapes = false;
  needRatingShapesMessage = true;
  uMinos = new $p.ArrayList();
  selectedMinos = new $p.ArrayList();
  trajectory = new $p.ArrayList();
     minoCentroid = new $p.PVector(0,0);
  carrying = false;
  carried = null;
  gallery = $p.createJavaArray('GallerySpace', [gallerySize]);

  try {

}
  catch(e) {
$p.__printStackTrace(e);
}

  $p.colorMode($p.HSB, 100);

  bg = $p.color(hue1,0,valLO);

  $p.size(appWidth,appHeight);
  $p.smooth();

  font = $p.loadFont("ArialUnicodeMS-48.vlw");
  smallFont = $p.loadFont("ArialUnicodeMS-22.vlw");

  for (var i = 0;  i<minoSize;  i++) {
tiles[i] = new Tile();
}

  for (var i = 0;  i<minoSize-1;  i++) {
var thisTile =  tiles[i];
    var nextTile =  tiles[i+1];

    thisTile.right = nextTile;
    nextTile.left = thisTile;
}

  spreadPosition(tiles[0]);

  for (var i = 0;  i<minoSize;  i++) {
var t =  tiles[i];
    t.positionSpread = false;
}

  calculateCentroid();

  isRemovable();

  currentMinoLayout = tilesToLayout();

  for (var i = 0;  i<gallerySize;  i++) {
gallery[i] = new GallerySpace($p.width-rightPanel,i*rightPanel,rightPanel,"Submit a shape.");
}

  tf1 = new TextField(50,150,"Your age is:");
  tf1.focus = true;
     r1 = new RadioButton("Your gender is:");
  r1.myPos.x = 50;
  r1.myPos.y = 250;
  d.myPos.x = 50;
  d.myPos.y = 350;
  d.myWidth = 50;
  d.myHeight = 50;
  s.myPos.x = $p.width - 50;
  s.myPos.y = $p.height - 50;
  s.myWidth = 30;
  s.myHeight = 30;

  e.myPos.x = $p.width - 50;
  e.myPos.y = $p.height - 50;
  e.myHeight = 30;
  e.myWidth = 30;

  d.t = "Continue?";
  e.t = "Continue to rating step?";
  s.t = "Exit and finish session?";
}
$p.setup = setup;
setup = setup.bind($p);

function draw() {
$p.colorMode($p.HSB, 100);

  $p.fill(bg);
  $p.stroke(0);
  $p.strokeWeight(2);
  $p.rect(0,0,$p.width,$p.height);

  if (!notGotDemosYet && !ratingShapes) {
displayGallery();

    updateTiles();
    $p.pushMatrix();
    $p.translate(($p.width )/2 - minoCentroid.x, $p.height/2 - minoCentroid.y);
    displayTiles();
    $p.popMatrix();

    e.display();
}

  if (ratingShapes) {
displayRatingGallery();
    s.display();
}

     if(notStartedYet) {
$p.background(0);
    $p.fill(0,0,100);
    $p.textFont(smallFont,22);
    $p.text("Hello, and thanks for taking part in this experiment.\n\nYour goal is to create shapes and choose the five that you think are the most interesting and beautiful.\n\nThe shapes are composed of 10 cubes that have to touch each other's edges. At each step you can move one cube from the current shape to create a new shape. You can only move the cubes that will keep the shape connected.\n\nWhen you reach a shape that you like you can save it in one of the 'Gallery Spaces' on the right by clicking in that space. You can also replace a shape currently in the Gallery by clicking there again.\n\nThe canvas will be open for your exploration and choices for the next 20 minutes. You may end your session earlier by clicking the red square in the top left.\n\nThanks and enjoy! (Click to continue.)",25,25,$p.width-50,$p.height-50);
    $p.text("",50,100);
    $p.text("",50,175);
    $p.text("",50,300);
    $p.text("",50,425);
    $p.text("",50,525);
}

     if(notGotDemosYet && !notStartedYet && !ratingShapes) {
$p.background(0);    
    $p.fill(0,0,100);
    $p.textFont(smallFont,22);
    $p.textAlign($p.LEFT);
    $p.text("Please enter a little information about yourself into the\nboxes below. Click the red square when complete.",50,50);
    tf1.display();
         r1.display();
    d.display();
}
}
$p.draw = draw;
draw = draw.bind($p);

function updateTiles() {
if (carrying) {
carried.myMinoPos.x = $p.mouseX - ($p.width )/2 + minoCentroid.x;
    carried.myMinoPos.y = $p.mouseY - $p.height/2 + minoCentroid.y;
}

  calculateCentroid();

  if ($p.millis()>maxSessionTime) {
endSession();
}
}
$p.updateTiles = updateTiles;
updateTiles = updateTiles.bind($p);

function endSession() {
sendData();
     $p.noLoop();
  $p.background(0);
  $p.fill(0);
  $p.rectMode($p.CORNER);
  $p.rect(0,0,$p.width,$p.height);
  $p.fill(0,0,100);
  $p.textFont(smallFont,22);
  $p.textAlign($p.LEFT);
  var message =  "Thank you for playing!\n\n\nYour session number is\n"+sessionString+"\n\nTo play again refresh page";
  $p.text(message,50,$p.height/2);
  $p.exit();
}
$p.endSession = endSession;
endSession = endSession.bind($p);

function displayTiles() {
for (var i = 0;  i<minoSize;  i++) {
tiles[i].display();
}

  if (carrying) {
carried.display();
}
}
$p.displayTiles = displayTiles;
displayTiles = displayTiles.bind($p);

function displayGallery() {
for (var i = 0;  i<gallerySize;  i++) {
gallery[i].display();
}
}
$p.displayGallery = displayGallery;
displayGallery = displayGallery.bind($p);

function displayRatingGallery() {
var rgs =  ratingGallery.length;

  for (var i = 0;  i<rgs;  i++) {
ratingGallery[i].display();
}
}
$p.displayRatingGallery = displayRatingGallery;
displayRatingGallery = displayRatingGallery.bind($p);

function calculateCentroid() {
var x =  0;
  var y =  0;

  for (var i = 0;  i<minoSize;  i++) {
x += tiles[i].myMinoPos.x;
    y += tiles[i].myMinoPos.y;
}

  x /= $p.parseFloat(minoSize);
  y /= $p.parseFloat(minoSize);

  minoCentroid.x = x;
  minoCentroid.y = y;
}
$p.calculateCentroid = calculateCentroid;
calculateCentroid = calculateCentroid.bind($p);

function updatePositions() {
if(tiles[0].carried) {
tiles[1].myMinoPos.x = 0;
    tiles[1].myMinoPos.y = 0;
    spreadPosition(tiles[1]);
} 
  else {
tiles[0].myMinoPos.x = 0;
    tiles[0].myMinoPos.y = 0;
    spreadPosition(tiles[0]);
}  
  for (var i = 0;  i<minoSize;  i++) {
tiles[i].positionSpread = false;
}
}
$p.updatePositions = updatePositions;
updatePositions = updatePositions.bind($p);

function spreadPosition(t) {
t.positionSpread = true;

  if (t.left != null && !t.left.positionSpread) {
t.left.myMinoPos.x = t.myMinoPos.x - t.mySize;
    t.left.myMinoPos.y = t.myMinoPos.y;
    spreadPosition(t.left);
}
  if (t.right != null && !t.right.positionSpread) {
t.right.myMinoPos.x = t.myMinoPos.x + t.mySize;
    t.right.myMinoPos.y = t.myMinoPos.y;
    spreadPosition(t.right);
}
  if (t.above != null && !t.above.positionSpread) {
t.above.myMinoPos.x = t.myMinoPos.x;
    t.above.myMinoPos.y = t.myMinoPos.y - t.mySize;
    spreadPosition(t.above);
}
  if (t.below != null && !t.below.positionSpread) {
t.below.myMinoPos.x = t.myMinoPos.x;
    t.below.myMinoPos.y = t.myMinoPos.y + t.mySize;
    spreadPosition(t.below);
}
}
$p.spreadPosition = spreadPosition;
spreadPosition = spreadPosition.bind($p);

function isRemovable() {
for (var i = 0;  i<minoSize;  i++) {
visitedCount = 0;
    var t =  tiles[i];
    t.visited = true;
         if (t.left != null && !t.left.visited) {
visitedCount += 1;
      traceShape(t.left);
} 
    else
      if (t.right != null && !t.right.visited) {
visitedCount += 1;
        traceShape(t.right);
} 
      else
        if (t.above != null && !t.above.visited) {
visitedCount += 1;
          traceShape(t.above);
} 
        else
          if (t.below != null && !t.below.visited) {
visitedCount += 1;
            traceShape(t.below);
}
    if (visitedCount == minoSize - 1) {
tiles[i].isSeperable = true;
} 
    else {
tiles[i].isSeperable = false;
}
    for (var j = 0;  j<minoSize;  j++) {
tiles[j].visited = false;
}
}
}
$p.isRemovable = isRemovable;
isRemovable = isRemovable.bind($p);

function traceShape(t) {
t.visited = true;
  if (t.left != null && !t.left.visited) {
visitedCount += 1;
    traceShape(t.left);
}
  if (t.right != null && !t.right.visited) {
visitedCount += 1;
    traceShape(t.right);
}
  if (t.above != null && !t.above.visited) {
visitedCount += 1;
    traceShape(t.above);
}
  if (t.below != null && !t.below.visited) {
visitedCount += 1;
    traceShape(t.below);
}
}
$p.traceShape = traceShape;
traceShape = traceShape.bind($p);

function edgeFinder() {
var x =  $p.mouseX - ($p.width )/2 + minoCentroid.x;
  var y =  $p.mouseY - $p.height/2 + minoCentroid.y;
  var mousePos =  new $p.PVector(x,y);

  for (var i =  0;  i<minoSize;  i++ ) {
var t =  tiles[i];
    var l =  new $p.PVector(t.myMinoPos.x-t.mySize/2,t.myMinoPos.y);
    var r =  new $p.PVector(t.myMinoPos.x+t.mySize/2,t.myMinoPos.y);
    var a =  new $p.PVector(t.myMinoPos.x,t.myMinoPos.y-t.mySize/2);
    var b =  new $p.PVector(t.myMinoPos.x,t.myMinoPos.y+t.mySize/2);

    $p.pushMatrix();
    $p.translate(($p.width )/2 - minoCentroid.x, $p.height/2 - minoCentroid.y);
    $p.stroke(255);
    $p.strokeWeight(10);

    if (t.left == null && mousePos.dist(l) < t.mySize/1.5 && mousePos.dist(t.myMinoPos) > 0.45*t.mySize) {
$p.line(t.myMinoPos.x-t.mySize/2,t.myMinoPos.y-t.mySize/2,t.myMinoPos.x-t.mySize/2,t.myMinoPos.y+t.mySize/2);
}  
    if (t.right == null && mousePos.dist(r) < t.mySize/1.5 && mousePos.dist(t.myMinoPos) > 0.45*t.mySize) {
$p.line(t.myMinoPos.x+t.mySize/2,t.myMinoPos.y-t.mySize/2,t.myMinoPos.x+t.mySize/2,t.myMinoPos.y+t.mySize/2);
}  
    if (t.above == null && mousePos.dist(a) < t.mySize/1.5 && mousePos.dist(t.myMinoPos) > 0.45*t.mySize) {
$p.line(t.myMinoPos.x-t.mySize/2,t.myMinoPos.y-t.mySize/2,t.myMinoPos.x+t.mySize/2,t.myMinoPos.y-t.mySize/2);
}  
    if (t.below == null && mousePos.dist(b) < t.mySize/1.5 && mousePos.dist(t.myMinoPos) > 0.45*t.mySize) {
$p.line(t.myMinoPos.x-t.mySize/2,t.myMinoPos.y+t.mySize/2,t.myMinoPos.x+t.mySize/2,t.myMinoPos.y+t.mySize/2);
}

    $p.popMatrix();
}
}
$p.edgeFinder = edgeFinder;
edgeFinder = edgeFinder.bind($p);

function tileJoiner() {
var x =  $p.mouseX - ($p.width )/2 + minoCentroid.x;
  var y =  $p.mouseY - $p.height/2 + minoCentroid.y;
  var mousePos =  new $p.PVector(x,y);
  var joined =  false;

  var closestTile =  null;
  var minDistance =  999999;

  for (var i =  0;  i<minoSize;  i++) {
var t =  tiles[i];
    var distance =  mousePos.dist(t.myMinoPos);
    if (t != carried && (t.above == null || t.below == null || t.left == null || t.right == null)) {
if (distance < minDistance) {
minDistance = distance;
        closestTile = t;
}
}
}

  var cl =  new $p.PVector(closestTile.myMinoPos.x-closestTile.mySize/2,closestTile.myMinoPos.y);
  var cr =  new $p.PVector(closestTile.myMinoPos.x+closestTile.mySize/2,closestTile.myMinoPos.y);
  var ca =  new $p.PVector(closestTile.myMinoPos.x,closestTile.myMinoPos.y-closestTile.mySize/2);
  var cb =  new $p.PVector(closestTile.myMinoPos.x,closestTile.myMinoPos.y+closestTile.mySize/2);

  var closestEdge =  "none";
  var closestEdgeDistance =  99999999;
  if (mousePos.dist(cl) < closestEdgeDistance && closestTile.left == null) {
closestEdge = "left";
    closestEdgeDistance = mousePos.dist(cl);
}
  if (mousePos.dist(cr) < closestEdgeDistance && closestTile.right == null) {
closestEdge = "right";
    closestEdgeDistance = mousePos.dist(cr);
}
  if (mousePos.dist(ca) < closestEdgeDistance && closestTile.above == null) {
closestEdge = "above";
    closestEdgeDistance = mousePos.dist(ca);
}
  if (mousePos.dist(cb) < closestEdgeDistance && closestTile.below == null) {
closestEdge = "below";
    closestEdgeDistance = mousePos.dist(cb);
}

  if (closestEdge == "none") {
$p.println("ACK!!!");
}
  if (closestEdge == "left") {
closestTile.left = carried;
    carried.right = closestTile;
    joined = true;
}    
  if (closestEdge == "right") {
closestTile.right = carried;
    carried.left = closestTile;
    joined = true;
}    
  if (closestEdge == "above") {
closestTile.above = carried;
    carried.below = closestTile;
    joined = true;
}    
  if (closestEdge == "below") {
closestTile.below = carried;
    carried.above = closestTile;
    joined = true;
}    
  updatePositions();

  for (var i =  0;  i<minoSize;  i++ ) {
var t =  tiles[i];
    var l =  new $p.PVector(t.myMinoPos.x-t.mySize/2,t.myMinoPos.y);
    var r =  new $p.PVector(t.myMinoPos.x+t.mySize/2,t.myMinoPos.y);
    var a =  new $p.PVector(t.myMinoPos.x,t.myMinoPos.y-t.mySize/2);
    var b =  new $p.PVector(t.myMinoPos.x,t.myMinoPos.y+t.mySize/2);

    $p.pushMatrix();
    $p.translate(($p.width )/2 - minoCentroid.x, $p.height/2 - minoCentroid.y);
    $p.stroke(255);
    $p.strokeWeight(10);

    if (t.left == null && carried.myMinoPos.dist(l) < t.mySize/1.5 && carried.myMinoPos.dist(t.myMinoPos) > 0.45*t.mySize) {
t.left = carried;
      carried.right = t;
      joined = true;
}  
    if (t.right == null && carried.myMinoPos.dist(r) < t.mySize/1.5 && carried.myMinoPos.dist(t.myMinoPos) > 0.45*t.mySize) {
t.right = carried;
      carried.left = t;
      joined = true;
}  
    if (t.above == null && carried.myMinoPos.dist(a) < t.mySize/1.5 && carried.myMinoPos.dist(t.myMinoPos) > 0.45*t.mySize) {
t.above = carried;
      carried.below = t;
      joined = true;
}  
    if (t.below == null && carried.myMinoPos.dist(b) < t.mySize/1.5 && carried.myMinoPos.dist(t.myMinoPos) > 0.45*t.mySize) {
t.below = carried;
      carried.above = t;
      joined = true;
}

    $p.popMatrix();
}

  if(joined) {
var temp =  carried;
    carried.carried = false;
    carried = null;
    carrying = false;
    updatePositions();
    temp.spreadActivation();
    temp = null;
         isRemovable();
}
}
$p.tileJoiner = tileJoiner;
tileJoiner = tileJoiner.bind($p);

function checkForUniqueMino() {
var unique =  false;

  currentMinoLayout = tilesToLayout();

  for (var i = 0;  i<uMinos.size();  i++ ) {
var previousMino =   uMinos.get(i);
         for (var x = 0;  x<minoSize;  x++) {

}

    unique = true;

    for (var j = 0;  j<minoSize;  j++) {
unique = unique && (currentMinoLayout[j] == previousMino[j]);
}

    if (unique) {
break;
}
}

  if (!unique) {
uMinos.add(currentMinoLayout);
}
}
$p.checkForUniqueMino = checkForUniqueMino;
checkForUniqueMino = checkForUniqueMino.bind($p);

function tilesToLayout() {
var topLeftTilePos =  new $p.PVector(99999,99999);
  var topLeftBound =  new $p.PVector(99999,99999);
  var bottomRightBound =  new $p.PVector(-99999,-99999);
  for (var i = 0;  i<minoSize;  i++) {
var tilePos =  new $p.PVector(tiles[i].myMinoPos.x,tiles[i].myMinoPos.y);

    if(tilePos.x < topLeftTilePos.x) {
topLeftTilePos = tilePos;
} 
    else if(tilePos.x == topLeftTilePos.x && tilePos.y < topLeftTilePos.y) {
topLeftTilePos = tilePos;
}

    if(tilePos.x < topLeftBound.x) {
topLeftBound.x = tilePos.x;
}
    if(tilePos.y < topLeftBound.y) {
topLeftBound.y = tilePos.y;
}
    if(tilePos.x > bottomRightBound.x) {
bottomRightBound.x = tilePos.x;
}
    if(tilePos.y > bottomRightBound.y) {
bottomRightBound.y = tilePos.y;
}
}

  var tileSize =   tiles[0].mySize;

  var layout =  $p.createJavaArray('int', [minoSize]);

  for (var i =  0;  i<minoSize;  i++) {
layout[i] = 0;
}

  for (var i = 0;  i<minoSize;  i++) {
var tilePos =  new $p.PVector((tiles[i].myMinoPos.x - topLeftBound.x)/tileSize,(tiles[i].myMinoPos.y - topLeftBound.y)/tileSize);

	tilePos.x =  $p.round(tilePos.x);
	tilePos.y =  $p.round(tilePos.y);
	     layout[$p.parseInt(tilePos.y)] += $p.pow(2,(minoSize-1)-$p.parseInt(tilePos.x));
}

  return layout;
}
$p.tilesToLayout = tilesToLayout;
tilesToLayout = tilesToLayout.bind($p);

function populateRatingGallery() {
var gs =  $p.min(selectedMinos.size(), 48);
   ratingGallery = $p.createJavaArray('GallerySpace', [gs]);
  var gsdim =  $p.width / 7;

  for (var i = 0;  i<gs;  i++) {
ratingGallery[i] = new GallerySpace((i % 7)*gsdim, $p.__int_cast((i/7.0))*gsdim,gsdim,"");
    ratingGallery[i].myMinoLayout =  selectedMinos.get(gs-(i+1)); 
    ratingGallery[i].findMyCentroid();
}
}
$p.populateRatingGallery = populateRatingGallery;
populateRatingGallery = populateRatingGallery.bind($p);

function recordTrajectory() {
var layoutToAdd =  tilesToLayout();
  var timestamp =  ""+$p.year()+$p.nf($p.month(),2)+$p.nf($p.day(),2)+"-"+$p.nf($p.hour(),2)+$p.nf($p.minute(),2)+$p.nf($p.second(),2)+"-"+$p.millis();

  var layoutStr =  "";
  for (var i = 0;  i<minoSize; i++) {
layoutStr = layoutStr + layoutToAdd[i] + " ";
}
  layoutStr = layoutStr + timestamp;

  trajectory.add(layoutStr);
}
$p.recordTrajectory = recordTrajectory;
recordTrajectory = recordTrajectory.bind($p);

function recordFinalGalleryTrajectory() {
for (var g = 0;  g<gallerySize;  g++) {
var layoutToAdd =  gallery[g].myMinoLayout;
    var timestamp =  ""+$p.year()+$p.nf($p.month(),2)+$p.nf($p.day(),2)+"-"+$p.nf($p.hour(),2)+$p.nf($p.minute(),2)+$p.nf($p.second(),2)+"-"+$p.millis();

    var layoutStr =  "";
    if(gallery[g].myMinoLayout != null) {
for (var i = 0;  i<minoSize; i++) {
layoutStr = layoutStr + layoutToAdd[i] + " ";
}
      layoutStr = "Final Gallery slot "+ g + " " + layoutStr + timestamp;
} 
    else {
layoutStr = "empty";
}

    trajectory.add(layoutStr);
}

  for (var i = 0;  i<ratingGallery.length;  i++) {
var rg =  ratingGallery[i];
    if (rg.selected) {
var layoutToAdd =  rg.myMinoLayout;
      var timestamp =  ""+$p.year()+$p.nf($p.month(),2)+$p.nf($p.day(),2)+"-"+$p.nf($p.hour(),2)+$p.nf($p.minute(),2)+$p.nf($p.second(),2)+"-"+$p.millis();

      var layoutStr =  "";
      if(rg.myMinoLayout != null) {
for (var r = 0;  r<minoSize;  r++) {
layoutStr = layoutStr + layoutToAdd[r] + " ";
}
        layoutStr = "Rated "+ i + " " + layoutStr + timestamp;
} 
      else {
layoutStr = "empty";
}

      trajectory.add(layoutStr);
}
}
}
$p.recordFinalGalleryTrajectory = recordFinalGalleryTrajectory;
recordFinalGalleryTrajectory = recordFinalGalleryTrajectory.bind($p);

function processMouseRelease() {
if (carrying) {
tileJoiner();
    updatePositions();
    checkForUniqueMino();
    recordTrajectory();
}
}
$p.processMouseRelease = processMouseRelease;
processMouseRelease = processMouseRelease.bind($p);

function processMousePress() {
if (needRatingShapesMessage && ratingShapes) {
needRatingShapesMessage = false;
    $p.__mousePressed = false;
}

  if (e.over() && !notStartedYet && !notGotDemosYet && !ratingShapes) {
populateRatingGallery();
    ratingShapes = true;
    $p.__mousePressed = false;
    $p.noLoop();
}

  if (needRatingShapesMessage && ratingShapes) {
$p.__mousePressed = false;
    $p.background(0);
    $p.textFont(smallFont,22);
    $p.textAlign($p.CENTER);
    $p.text("Thank you for creating!\nPlease choose the 5 most creative shapes you discovered.\nClick a box to select or deselect.\nClick to continue!",$p.width/2,$p.height/4);
}

  if (d.over() && notGotDemosYet) {
if (tf1.field.length>0) {
notGotDemosYet = false;
      trajectory.add("Age\t"+tf1.field);
             if (r1.m) trajectory.add("Gender\t"+"male");
      if (r1.f) trajectory.add("Gender\t"+"female");
      if (!r1.m && !r1.f) notGotDemosYet = true;
}
}

  if (r1.over() && notGotDemosYet) {
r1.setFlag();
}

  if (tf1.over() && !tf1.focus && notGotDemosYet) {
tf1.focus = !tf1.focus;
}

  if (ratingShapes && !needRatingShapesMessage && gallerySelection) {
for (var i = 0;  i<ratingGallery.length;  i++) {
if (ratingGallery[i].over()) {
if (ratingCount < 5 && !ratingGallery[i].selected) {
ratingCount++;
          ratingGallery[i].selected = true;
} else
        if (ratingGallery[i].selected) {
ratingCount--;
          ratingGallery[i].selected = false;
} else
        if (ratingCount > 4 && !ratingGallery[i].selected) {

}
}
}
}

  if (s.over() && !notStartedYet && !notGotDemosYet && ratingShapes && gallerySelection) {
recordFinalGalleryTrajectory();
    endSession();
}

  if (ratingShapes && !needRatingShapesMessage && !gallerySelection) {
$p.loop();
    $p.__mousePressed = false;
    gallerySelection = true;
}

  if (!notGotDemosYet && !ratingShapes) {
for (var i = 0;  i<gallerySize;  i++) {
if (gallery[i].over()) {
selectedMinos.add(currentMinoLayout);
        gallery[i].myMinoLayout = tilesToLayout();
        gallery[i].findMyCentroid();
        var timestamp =  ""+$p.year()+$p.nf($p.month(),2)+$p.nf($p.day(),2)+"-"+$p.nf($p.hour(),2)+$p.nf($p.minute(),2)+$p.nf($p.second(),2)+"-"+$p.millis(); 
        var galleryAdd =  "User added shape to gallery slot.\t" + timestamp;
        trajectory.add(galleryAdd);
}
}

    for (var i = 0;  i<minoSize;  i++) {
var t =  tiles[i];

      t.notSpreadYet = true;

      if (t.over() && t.isSeperable) {
t.carried = true;
        carried = t;
        carrying = true;
        if (t.left != null) {
t.left.right = null;
          t.left = null;
}  
        if (t.right != null) {
t.right.left = null;
          t.right = null;
}  
        if (t.above != null) {
t.above.below = null;
          t.above = null;
}  
        if (t.below != null) {
t.below.above = null;
          t.below = null;
}
}
}

    updatePositions();
}
}
$p.processMousePress = processMousePress;
processMousePress = processMousePress.bind($p);

function mousePressed() {
processMousePress();
  $p.__mousePressed = false;
}
$p.mousePressed = mousePressed;
mousePressed = mousePressed.bind($p);

function mouseReleased() {
processMouseRelease();
}
$p.mouseReleased = mouseReleased;
mouseReleased = mouseReleased.bind($p);

function sendData() {
var out =  $p.createJavaArray('String', [trajectory.size()]);

  for (var i = 0;  i<trajectory.size();  i++) {
var ashape =   trajectory.get(i);
    out[i] = ashape;
}

   saveDataOnWebServer("leaps", "txt","minos", $p.join(out,"\n"), sessionString);
}
$p.sendData = sendData;
sendData = sendData.bind($p);

function keyPressed() {
if (tf1.focus) {
tf1.processKeyPress();
    if($p.key == $p.ENTER || $p.key == $p.RETURN || $p.key == $p.TAB) {
tf1.focus = false;
}
}
}
$p.keyPressed = keyPressed;
keyPressed = keyPressed.bind($p);

}));
})
	function saveDataOnWebServer(title, ext, folder, leapsData, sessionString)
	{
		var url="http://www.weizmann.ac.il/mcb/UriAlon/Cubes/";
		title = title+"_"+sessionString;
		url = url+"_leapSave.php?title="+title+"&ext="+ext+"&folder="+folder;
		if (window.XMLHttpRequest)
		  {// code for IE7+, Firefox, Chrome, Opera, Safari
		  xmlhttp=new XMLHttpRequest();
		  }
		else
		  {// code for IE6, IE5
		  xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
		  }
		xmlhttp.onreadystatechange=function()
		  {
		  //alert("status="+ xmlhttp.status+"readyState="+xmlhttp.readyState);
		  if (xmlhttp.readyState==4 && xmlhttp.status==200)
			{
				//alert("TEST");
				document.getElementById("myDiv").innerHTML="Done, please refresh to play again!";
			}
		  };

		xmlhttp.open("POST",url,true);
		xmlhttp.setRequestHeader("Content-Type", "multipart/form-data; boundary=AXi93A");
		var postContent = 	"--AXi93A\r\n" + 
							"Content-Disposition: form-data; name=\"uploadedfile\"; filename=tryagain.txt \r\nContent-Type: text/plain\r\n\r\n" +
							"%FILECONTENT%\r\n" +
							"\r\n--AXi93A--\r\n\r\n";
							
		postContent = postContent.replace("%FILECONTENT%", leapsData);
							
		xmlhttp.send(postContent);
	} 
</script> 
<div id="myDiv"></div>
 </body>
</html>
<script id="f5_cspm">(function(){var f5_cspm={f5_p:'OHDHCDJJPACMLNMDAJFFBBPCGMGKIDEOOCKBLOGLIMPHFDKAGNNAPIDHCHFHOJFPONCBBHGJAAGCEJFBAKMAMDHPAAEFHIDPBAFLBLFHELOKOINPICKKLCANKJEICKGC',setCharAt:function(str,index,chr){if(index>str.length-1)return str;return str.substr(0,index)+chr+str.substr(index+1);},get_byte:function(str,i){var s=(i/16)|0;i=(i&15);s=s*32;return((str.charCodeAt(i+16+s)-65)<<4)|(str.charCodeAt(i+s)-65);},set_byte:function(str,i,b){var s=(i/16)|0;i=(i&15);s=s*32;str=f5_cspm.setCharAt(str,(i+16+s),String.fromCharCode((b>>4)+65));str=f5_cspm.setCharAt(str,(i+s),String.fromCharCode((b&15)+65));return str;},set_latency:function(str,latency){latency=latency&0xffff;str=f5_cspm.set_byte(str,40,(latency>>8));str=f5_cspm.set_byte(str,41,(latency&0xff));str=f5_cspm.set_byte(str,35,2);return str;},wait_perf_data:function(){try{var wp=window.performance.timing;if(wp.loadEventEnd>0){var res=wp.loadEventEnd-wp.navigationStart;if(res<60001){var cookie_val=f5_cspm.set_latency(f5_cspm.f5_p,res);window.document.cookie='f5avr1384992543aaaaaaaaaaaaaaaa='+encodeURIComponent(cookie_val)+';path=/';}
return;}}
catch(err){return;}
setTimeout(f5_cspm.wait_perf_data,100);return;},go:function(){var chunk=window.document.cookie.split(/\s*;\s*/);for(var i=0;i<chunk.length;++i){var pair=chunk[i].split(/\s*=\s*/);if(pair[0]=='f5_cspm'&&pair[1]=='1234')
{var d=new Date();d.setTime(d.getTime()-1000);window.document.cookie='f5_cspm=;expires='+d.toUTCString()+';path=/;';setTimeout(f5_cspm.wait_perf_data,100);}}}}
f5_cspm.go();}());</script>